\documentclass{article}
\usepackage{hyperref}
\usepackage[nohyphen]{underscore}
\usepackage[english]{babel}
\newcommand{\code}[1]{\texttt{#1}}
\begin{document}
\title{Modular Wayland compositors with wlroots}
\author{Drew DeVault et al
    \thanks{Complete list available at \url{https://github.com/swaywm/wlroots/graphs/contributors}}}
\maketitle

\begin{abstract}
wlroots is a flexible and modular library upon which Wayland compositors can be
built. It is designed to maximize several factors: code reusability,
interoperability between Wayland compositors, and flexibility for use in novel
compositor designs.
\end{abstract}

\newpage
\tableofcontents

\newpage
\section{Background}\label{background}

Wayland is a protocol used to communicate between user applications and a
\emph{compositor}. The compositor has ownership over input and output
resources -- typically displays connected over DVI, HDMI, etc, and keyboards,
mice, etc.

wlroots (stylized in lowercase, or as "wlr") is a subproject of the Sway
compositor. Originally, Sway was written on top of a similar library called wlc.
This library offered abstractions on top of DRM, GBM, GLES, libinput, and so on
-- allowing Sway to focus on building the software specific to the compositor.
However, with time it became clear that wlc's design is too limiting, and many
of Sway's long-term goals were difficult to achieve based on it.

\subsection{Alternatives}\label{alternatives}

Several alternative approaches to building compositors exist.\\

\textbf{libweston} is the most notable alternative. It is a subproject of the
Weston compositor, the reference Wayland compositor. However, it is generally
poorly suited to novel compositors that don't use the traditional desktop
paradigm. It is also less modular and difficult to break into several pieces.
Additionally, as a consequence of being refactored out of an existing
compositor, it inherits many design decisions of Weston itself, which may not be
amenable to other compositors.

\textbf{swc} and \textbf{wlc} are similar. They both strike a reasonable balance
between size and features, but both make decisions for the compositor that lock
them into particular designs and make novel compositors more difficult to
write. The advantage of their approach is that it is easy to use them to build a
simple working compositor - in a matter of minutes, not days or weeks.

Another approach is to simply write your compositor entirely in-house. This is
the approach favored by \textbf{mutter} and \textbf{kwin} of the GNOME and KDE
projects respectively. The advantage of this approach is the flexibility to
design your compositor in any way you please. However, lots of work is
duplicated between projects with this approach, which can lead to compositors
which are subtly incompatible with each other.

The approach taken by \textbf{wlroots} offers reusability and consistency
between compositors based on it, and offloads lots of work from the compositor
implementation. This is accomplished without making design decisions on behalf
of the compositor implementation: we believe virtually any novel kind of
compositor can be built on top of wlroots.

The main disadvantage of our approach is that batteries are not included. More
work is required to get a working compositor compared to libweston or wlc.
However, you will not hit the limitations of these libraries, and will more
quickly arrive at a diverse featureset than with the kwin or mutter approaches.

\section{High-level Architecture}\label{highlevel}

wlroots is organized into many discrete components that can be used separately
or replaced with your own implementations, and freely composed.

\subsection{Backends}\label{high level backends}

Backends are used to abstract access to input and output hardware. A backend,
once initialized, provides some number of \textbf{wlr_outputs} and
\textbf{wlr_input_devices}, the latter being an abstraction on top of types
like \textbf{wlr_pointer}, \textbf{wlr_keyboard}, \textbf{wlr_touch}, and so on.

Backends include \emph{drm} and \emph{libinput}, which abstract the
corresponding Linux subsystems; \emph{wayland}, which uses Wayland windows on
another running Wayland compositor; the similar \emph{x11} backend; \emph{rdp},
which uses the remote desktop protocol; and so on. An interface is provided so
that compositor implementations can supply their own backend implementations as
well.

Also available is the \emph{multi} backend, which acts as a container for many
backends. This is necessary, for example, to use DRM and libinput together. It
also allows you to add and remove backends at runtime. An example use-case:
adding an rdp backend at runtime.

\subsection{Types}\label{high level types}

Types are at the heart of wlroots. They offer small, composable bits of
functionality, and include simple data structures like \textbf{wlr_box},
implementations of Wayland interfaces like \textbf{wlr_wl_shell}, and wlr tools
like \textbf{wlr_cursor}. Also included are types like \textbf{wlr_keyboard},
which are abstractions for backend types. Types like this are generally
accompanied by an \emph{interface}, which can be implemented by compositors and
integrated with other parts of wlroots.

\subsection{Rootston}\label{rootston}

Our reference compositor is Rootston, and it is used to develop most wlroots
features as well as to serve as a demonstration of how they are used.

\newpage
\section{Backends}\label{backends}

\subsection{Backend initialization}\label{backend init}

There are two steps to setting up a backend -- first they are created, and then
they are started. During creation, the backend will obtain access to the
resources it needs, configure events on the event loop, test for required
features, and so on. During this stage, backends providing outputs are also
expected to configure their EGL context. Starting a backend will begin
presenting itself to the user and will start to create input and output devices
and pass them to the compositor. Backends are started with
\textbf{wlr_backend_start}, available in \code{wlr/backend.h}. Creation is more
subtle.

\subsection{Automatic selection}\label{backend autocreate}

The simplest way to obtain a backend is with \textbf{wlr_backend_autocreate},
available in \code{wlr/backend.h}. It will examine the runtime environment and
return the most suitable \textbf{wlr_backend}.

\subsection{Multi-backend}\label{multi backend}

A backend is available in \code{wlr/backend/multi.h} which can encapsulate many
other backends. Inputs and outputs added in these several backends can be
bubbled up through the multi-backend as if it were a single backend. Backends
can also be added to and removed from a multi-backend at runtime.

\subsection{DRM}\label{drm backend}

TODO

\subsection{Libinput}\label{libinput backend}

TODO

\subsection{Wayland}\label{wl backend}

The Wayland backend, available in \code{wlr/backend/wayland.h}, allows you to
open Wayland windows on a different Wayland compositor and treat them as
\textbf{wlr_outputs} for nesting compositors. You may add \textbf{wlr_outputs}
dynamically at runtime with \textbf{wlr_wl_output_create} (and in fact you must
add at least one of these explicitly for the backend to be effective).

\subsection{X11}\label{x11 backend}

TODO

\subsection{RDP}\label{rdp backend}

TODO

\subsection{Headless}\label{headless backend}

TODO

\newpage
\section{Rendering}\label{rendering}

Note: ascent12 is changing a lot of this right now

\subsection{EGL}

TODO

\subsection{GLES}

TODO

\newpage
\section{Input}\label{input}

TODO

\subsection{Keyboard Handling}\label{keyboard handling}

TODO

\subsection{wlr_seat}\label{wlr seat summary}

TODO

\subsection{Multi-seat}\label{multi seat}

TODO

\newpage
\section{Wayland Shells}\label{shells}

TODO

\newpage
\section{Security}\label{security}

TODO

\newpage
\section{Types}\label{types}

There are various kinds of types in wlroots. It is useful to explain the broad
purpose of each kind of type.

\subsection{Data Structures}\label{data structures}

Some types are implementations of simple data structures, and are useful as
inputs to functions throughout wlroots or as storage for certain kinds of
information.

\begin{itemize}
    \itemsep0em
    \item \nameref{wlr box}
    \item \nameref{wlr list}
    \item \nameref{wlr matrix}
\end{itemize}

\subsection{Convenience Types}\label{convenience types}

These optional types provide convenience for the compositor by implementing
functionality common to many Wayland compositors.

\begin{itemize}
    \itemsep0em
    \item \nameref{wlr cursor}
    \item \nameref{wlr output layout}
\end{itemize}

\subsection{Hardware Abstractions}\label{hardware abstractions}

Several types are available that abstract the hardware provided by backends.
There is some overlap with \nameref{wl interfaces}, as many of these types
are made available to clients as well, generally with the compositor's consent.

\begin{itemize}
    \itemsep0em
    \item \nameref{wlr input device}
    \item \nameref{wlr keyboard}
    \item \nameref{wlr output}
    \item \nameref{wlr pointer}
    \item \nameref{wlr tablet pad}
    \item \nameref{wlr tablet tool}
    \item \nameref{wlr touch}
\end{itemize}

\subsection{Wayland Interfaces}\label{wl interfaces}

These types implement a specific interface in the (or \emph{a}) Wayland
protocol. They implement much of the boilerplate, any useful state handling,
raise events when necessary, and offer users functions for manipulating their
resources. Note that there is some overlap with convenience types here. Many
resoruces, such as \textbf{wlr_output}, provide functionality for both the
compositor's benefit and the Wayland client.

\begin{itemize}
    \itemsep0em
    \item \nameref{wlr compositor}
    \item \nameref{wlr data device}
    \item \nameref{wlr keyboard}
    \item \nameref{wlr output}
    \item \nameref{wlr pointer}
    \item \nameref{wlr region}
    \item \nameref{wlr screenshooter}
    \item \nameref{wlr seat}
    \item \nameref{wlr server decoration}
    \item \nameref{wlr surface}
    \item \nameref{wlr tablet pad}
    \item \nameref{wlr tablet tool}
    \item \nameref{wlr touch}
    \item \nameref{wlr wl shell}
    \item \nameref{wlr xdg shell v6}
\end{itemize}

\subsection{Special Types}\label{special types}

Some types are spread throughout their respective subsystems and are not
included in \code{include/types/*.h}. These include:

\begin{itemize}
    \itemsep0em
    \item \nameref{wlr backend}
    \item \nameref{wlr renderer}
    \item \nameref{wlr texture}
    \item \nameref{wlr xcursor}
    \item \nameref{wlr xwayland}
\end{itemize}

\newpage
\section{Type Reference}\label{type reference}

\subsection{wlr_backend}\label{wlr backend}

\code{wlr/backend.h}\\

This type abstracts the functionality of hardware backends. For an overview of
this system and available backends see \nameref{high level backends}.

\subsection{wlr_box}\label{wlr box}

\code{wlr/types/wlr_box.h}\\

\textbf{wlr_box} is a simple data structure:

\begin{verbatim}
struct wlr_box {
    int x, y;
    int width, height;
};
\end{verbatim}

A number of utility functions are available in the header.

\subsection{wlr_compositor}\label{wlr compositor}

\code{wlr/types/wlr_compositor.h}\\

\textbf{wlr_compositor} is an implementation of the \textbf{wl_compositor}
interface. Generally this is not directly useful to compositor implementations,
as the surfaces created by it will have no role. Nevertheless, a new_surface
event is provided.

\subsection{wlr_cursor}\label{wlr cursor}

\code{wlr/types/wlr_cursor.h}\\

\textbf{wlr_cursor} is an abstraction for cursors; that is, the cursor image
that appears on-screen. It is able bind one or more input devices to a single
on-screen cursor, and configure them to be bound to a \nameref{wlr output
layout}, specific displays, or regions of the screen.

\subsection{wlr_data_device}\label{wlr data device}

\code{wlr/types/wlr_data_device.h}\\

\textbf{wlr_data_device} implements the \textbf{wl_data_device_manager}
interface and related sub-interfaces. It is used for clipboard handling and
drag-and-drop operations. Clipboard handling largely takes care of itself, but
drag-and-drop requries some involvement from the compositor implementation.

\subsection{wlr_gamma_control}\label{wlr gamma control}

\code{wlr/types/wlr_gamma_control.h}\\

\textbf{wlr_gamma_control} implements the Orbital gamma control protocol, and
largely takes care of itself once initialized.

\subsection{wlr_input_device}\label{wlr input device}

\code{wlr/types/wlr_input_device.h}\\

\textbf{wlr_input_device} is a container for an arbitrary kind of input device.
Based on the value of \code{wlr_input_device.type}, one of the pointers in the
union is valid and contains state specific to each device type.

\subsection{wlr_keyboard}\label{wlr keyboard}

\code{wlr/types/wlr_keyboard.h}\\

\textbf{wlr_keyboard} provides an abstraction for backend-specific keyboard
hardware, and also manages a xkb_keymap and xkb_state for the keyboard.

\subsection{wlr_list}\label{wlr list}

\code{wlr/types/wlr_list.h}\\

\textbf{wlr_list} is a simple list of \code{void*} pointers that grows and
shrinks in memory. It is used when \textbf{wl_list} does not suffice.

\subsection{wlr_matrix}\label{wlr matrix}

\code{wlr/render/matrix.h}\\

\textbf{wlr_matrix} contains a 4x4 matrix, useful in graphics operations.
Several utility functions are provided for matrix arithmetic and preparing stock
matricies for 2D and 3D transformations.

\subsection{wlr_output}\label{wlr output}

\code{wlr/types/wlr_output.h}\\

\textbf{wlr_output} abstracts access to display hardware provided by backends.
The most important functionality offered by \textbf{wlr_outputs} is the frame
event. The output will raise this event when it is ready to accept a new frame.
You should make the EGL context current via \code{wlr_output_make_current},
render your frame, and use \code{wlr_output_swap_buffers} to present it.\\

Additionally, \textbf{wlr_outputs} offer hardware cursors. In the event that
hardware cursors are not supported on a particular backend, software cursors
are used automatically. TODO: the details of this functionality are going to
change.\\

\code{wlr/interfaces/wlr_output.h} contains an interface you may use to
provide your own wlr_output implementations.

\subsection{wlr_output_layout}\label{wlr output layout}

\code{wlr/types/wlr_output_layout.h}\\

\textbf{wlr_output_layout} provides a mechanism for arranging
\textbf{wlr_outputs} in physical space. It provides functionality for arranging
a virtual desktop, translating global coordinates to output space, and
intersecting boxes with outputs. It can also be used to mirror outputs.

\subsection{wlr_pointer}\label{wlr pointer}

\code{wlr/types/wlr_pointer.h}\\

\textbf{wlr_pointer} provides an abstraction for backend-specific pointer
hardware.

\subsection{wlr_region}\label{wlr region}

\code{wlr/types/wlr_region.h}\\

\textbf{wlr_region} is an implementation of \textbf{wl_region} backed by
a pixman_region32_t.

\subsection{wlr_renderer}\label{wlr renderer}

\code{wlr/render.h}\\

TODO

\subsection{wlr_screenshooter}\label{wlr screenshooter}

\code{wlr/types/wlr_screenshooter.h}\\

\textbf{wlr_screenshooter} is an implementation of the Orbital screenshooter
protocol, which is itself a fork of the Weston screenshooter protocol. Once
initialized it largely takes care of itself.

\subsection{wlr_seat}\label{wlr seat}

\code{wlr/types/wlr_seat.h}\\

\textbf{wlr_seat} is an implementation of the \textbf{wl_seat} interface. It is
responsible for communicating input events to a client, and the compositor
implementation is responsible for communicating input events to
\textbf{wlr_seat}. All input events are then dispatched through a keyboard or
pointer \emph{grab}. By default the grab dispatches events normally, but certain
shells use grabs for some features like drop-down menus to temporarily take
greater control over the seat's input.

It is up to the compositor implementation to implement focus semantics and
communicate to \textbf{wlr_seat} how to dispatch events to which clients.

\subsection{wlr_server_decoration}\label{wlr server decoration}

\code{wlr/types/wlr_server_decoration.h}\\

\textbf{wlr_server_decoration} is an implementation of KDE's server decoration
protocol. It is used to negotiate client- versus server-side window decorations
with Wayland clients.

\subsection{wlr_surface}\label{wlr surface}

\code{wlr/types/wlr_surface.h}\\

\textbf{wlr_surface} is an implementation of the \textbf{wl_surface} interface.
It is a double buffered state machine that clients can attach
\textbf{wl_buffers} to (backed by \textbf{wlr_textures}) and configure their
appearance. During rendering, the compositor implementation will be provided
\textbf{wlr_surfaces} by each shell and should display them as they see fit.
This is a very complicated interface, be thankful we did it for you.

\subsection{wlr_tablet_pad}\label{wlr tablet pad}

\code{wlr/types/wlr_tablet_pad.h}\\

\textbf{wlr_tablet_pad} provides an abstraction for backend-specific tablet pad
hardware -- that is, the "pad" part of a drawling tablet.

\subsection{wlr_tablet_tool}\label{wlr tablet tool}

\code{wlr/types/wlr_tablet_tool.h}\\

\textbf{wlr_tablet_tool} provides an abstraction for backend-specific tablet
tool hardware -- that is, the "pen" part of a drawling tablet.

\subsection{wlr_texture}\label{wlr texture}

\code{wlr/render.h}

A \textbf{wlr_texture} stores state related to a texture on the GPU. It also
provides convenience functions for uploading pixels from pointers, Wayland
shared memory buffers, or DRM buffers.

\subsection{wlr_touch}\label{wlr touch}

\code{wlr/types/wlr_touch.h}\\

\textbf{wlr_tablet_tool} provides an abstraction for backend-specific (multi-)
touch hardware.

\subsection{wlr_wl_shell}\label{wlr wl shell}

\code{wlr/types/wlr_wl_shell.h}\\

\textbf{wlr_wl_shell} implements the \textbf{wl_shell} interface. Events are
raised when surfaces are bound to this role, as well as when the client requests
resize, move, etc.

\subsection{wlr_xcursor}\label{wlr xcursor}

\code{wlr/xcursor.h}\\

\textbf{wlr_xcursor} is a small utility library based on \emph{wayland-cursor}
that allows you to load a \textbf{wlr_xcursor_theme} and read cursor data from
it. This is useful for setting the cursor image in your compositor when no
clients are currently providing them.

\subsection{wlr_xdg_shell_v6}\label{wlr xdg shell v6}

\code{wlr/types/wlr_xdg_shell_v6.h}\\

\textbf{wlr_xdg_shell_v6} implements the \textbf{xdg-shell-v6} protocol. Events
are raised when surfaces are bound to this role, as well as when the client
requests resize, move, etc.

\subsection{wlr_xwayland}\label{wlr xwayland}

\code{wlr/types/wlr_xwayland.h}\\

\textbf{wlr_xwayland} can spawn an Xwayland server and provides an interface
similar to wlroots' other shells for managing X11 client surfaces.

\end{document}
