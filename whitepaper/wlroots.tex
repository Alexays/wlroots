\documentclass{article}
\usepackage{hyperref}
\usepackage[nohyphen]{underscore}
\usepackage[english]{babel}
\newcommand{\code}[1]{\texttt{#1}}
\begin{document}
\title{Modular Wayland compositors with wlroots}
\author{Drew DeVault et al
    \thanks{Complete list available at \url{https://github.com/swaywm/wlroots/graphs/contributors}}}
\maketitle

\begin{abstract}
wlroots is a flexible and modular library upon which Wayland compositors can be
built. It is designed to maximize several factors: code reusability,
interoperability between Wayland compositors, and flexibility for use in novel
compositor designs.
\end{abstract}

\newpage
\tableofcontents

\newpage
\section{Background}\label{background}

Wayland is a protocol used to communicate between user applications and a
\emph{compositor}. The compositor has ownership over input and output
resources -- typically displays connected over DVI, HDMI, etc, and keyboards,
mice, etc.

wlroots (stylized in lowercase, or as "wlr") is a subproject of the Sway
compositor. Originally, Sway was written on top of a similar library called wlc.
This library offered abstractions on top of DRM, GBM, GLES, libinput, and so on
-- allowing Sway to focus on building the software specific to the compositor.
However, with time it became clear that wlc's design is too limiting, and many
of Sway's long-term goals were difficult to achieve based on it.

\subsection{Alternatives}\label{alternatives}

Several alternative approaches to building compositors exist.\\

\textbf{libweston} is the most notable alternative. It is a subproject of the
Weston compositor, the reference Wayland compositor. However, it is generally
poorly suited to novel compositors that don't use the traditional desktop
paradigm. It is also less modular and difficult to break into several pieces.
Additionally, as a consequence of being refactored out of an existing
compositor, it inherits many design decisions of Weston itself, which may not be
amenable to other compositors.

\textbf{swc} and \textbf{wlc} are similar. They both strike a reasonable balance
between size and features, but both make decisions for the compositor that lock
them into particular designs and make novel compositors more difficult to
write. The advantage of their approach is that it is easy to use them to build a
simple working compositor - in a matter of minutes, not days or weeks.

Another approach is to simply write your compositor entirely in-house. This is
the approach favored by \textbf{mutter} and \textbf{kwin} of the GNOME and KDE
projects respectively. The advantage of this approach is the flexibility to
design your compositor in any way you please. However, lots of work is
duplicated between projects with this approach, which can lead to compositors
which are subtly incompatible with each other.

The approach taken by \textbf{wlroots} offers reusability and consistency
between compositors based on it, and offloads lots of work from the compositor
implementation. This is accomplished without making design decisions on behalf
of the compositor implementation: we believe virtually any novel kind of
compositor can be built on top of wlroots.

The main disadvantage of our approach is that batteries are not included. More
work is required to get a working compositor compared to libweston or wlc.
However, you will not hit the limitations of these libraries, and will more
quickly arrive at a diverse featureset than with the kwin or mutter approaches.

\section{High-level Architecture}\label{highlevel}

wlroots is organized into many discrete components that can be used separately
or replaced with your own implementations, and freely composed.

\subsection{Backends}\label{high level backends}

Backends are used to abstract access to input and output hardware. A backend,
once initialized, provides some number of \textbf{wlr_outputs} and
\textbf{wlr_input_devices}, the latter being an abstraction on top of types
like \textbf{wlr_pointer}, \textbf{wlr_keyboard}, \textbf{wlr_touch}, and so on.

Backends include \emph{drm} and \emph{libinput}, which abstract the
corresponding Linux subsystems; \emph{wayland}, which uses Wayland windows on
another running Wayland compositor; the similar \emph{x11} backend; \emph{rdp},
which uses the remote desktop protocol; and so on. An interface is provided so
that compositor implementations can supply their own backend implementations as
well.

Also available is the \emph{multi} backend, which acts as a container for many
backends. This is necessary, for example, to use DRM and libinput together. It
also allows you to add and remove backends at runtime. An example use-case:
adding an rdp backend at runtime.

\subsection{Types}\label{high level types}

Types are at the heart of wlroots. They offer small, composable bits of
functionality, and include simple data structures like \textbf{wlr_box},
implementations of Wayland interfaces like \textbf{wlr_wl_shell}, and wlr tools
like \textbf{wlr_cursor}. Also included are types like \textbf{wlr_keyboard},
which are abstractions for backend types. Types like this are generally
accompanied by an \emph{interface}, which can be implemented by compositors and
integrated with other parts of wlroots.

\subsection{Rootston}\label{rootston}

Our reference compositor is Rootston, and it is used to develop most wlroots
features as well as to serve as a demonstration of how they are used.

\newpage
\section{Backends}\label{backends}

\subsection{Backend initialization}\label{backend init}

There are two steps to setting up a backend -- first they are created, and then
they are started. During creation, the backend will obtain access to the
resources it needs, configure events on the event loop, test for required
features, and so on. During this stage, backends providing outputs are also
expected to configure their EGL context. Starting a backend will begin
presenting itself to the user and will start to create input and output devices
and pass them to the compositor. Backends are started with
\textbf{wlr_backend_start}, available in \code{wlr/backend.h}. Creation is more
subtle.

\subsection{Automatic selection}\label{backend autocreate}

The simplest way to obtain a backend is with \textbf{wlr_backend_autocreate},
available in \code{wlr/backend.h}. It will examine the runtime environment and
return the most suitable \textbf{wlr_backend}.

\subsection{Multi-backend}\label{multi backend}

A backend is available in \code{wlr/backend/multi.h} which can encapsulate many
other backends. Inputs and outputs added in these several backends can be
bubbled up through the multi-backend as if it were a single backend. Backends
can also be added to and removed from a multi-backend at runtime.

\subsection{DRM}\label{drm backend}

TODO

\subsection{Libinput}\label{libinput backend}

TODO

\subsection{Wayland}\label{wl backend}

The Wayland backend, available in \code{wlr/backend/wayland.h}, allows you to
open Wayland windows on a different Wayland compositor and treat them as
\textbf{wlr_outputs} for nesting compositors. You may add \textbf{wlr_outputs}
dynamically at runtime with \textbf{wlr_wl_output_create} (and in fact you must
add at least one of these explicitly for the backend to be effective).

\subsection{X11}\label{x11 backend}

TODO

\subsection{RDP}\label{rdp backend}

TODO

\subsection{Headless}\label{headless backend}

TODO

\newpage
\section{Rendering}\label{rendering}

Note: ascent12 is changing a lot of this right now

\subsection{EGL}

TODO

\subsection{GLES}

TODO

\newpage
\section{Input}\label{input}

TODO

\subsection{Cursors}\label{wlr cursor summary}

TODO

\subsection{Keyboard Handling}\label{keyboard handling}

TODO

\subsection{wlr_seat}\label{wlr seat summary}

TODO

\subsection{Multi-seat}\label{multi seat}

TODO

\newpage
\section{Wayland Shells}\label{shells}

TODO

\newpage
\section{Types}\label{types}

There are various kinds of types in wlroots. It is useful to explain the broad
purpose of each kind of type.

\subsection{Data Structures}\label{data structures}

Some types are implementations of simple data structures, and are useful as
inputs to functions throughout wlroots or as storage for certain kinds of
information.

\begin{itemize}
    \itemsep0em
    \item \nameref{wlr box}
    \item \nameref{wlr list}
    \item \nameref{wlr matrix}
\end{itemize}

\subsection{Convenience Types}\label{convenience types}

These optional types provide convenience for the compositor by implementing
functionality common to many Wayland compositors.

\begin{itemize}
    \itemsep0em
    \item \nameref{wlr cursor}
    \item \nameref{wlr output layout}
\end{itemize}

\subsection{Hardware Abstractions}\label{hardware abstractions}

Several types are available that abstract the hardware provided by backends.
There is some overlap with \nameref{wl interfaces}, as many of these types
are made available to clients as well, generally with the compositor's consent.

\begin{itemize}
    \itemsep0em
    \item \nameref{wlr input device}
    \item \nameref{wlr keyboard}
    \item \nameref{wlr output}
    \item \nameref{wlr pointer}
    \item \nameref{wlr tablet pad}
    \item \nameref{wlr tablet tool}
    \item \nameref{wlr touch}
\end{itemize}

\subsection{Wayland Interfaces}\label{wl interfaces}

These types implement a specific interface in the (or \emph{a}) Wayland
protocol. They implement much of the boilerplate, any useful state handling,
raise events when necessary, and offer users functions for manipulating their
resources. Note that there is some overlap with convenience types here. Many
resoruces, such as \textbf{wlr_output}, provide functionality for both the
compositor's benefit and the Wayland client.

\begin{itemize}
    \itemsep0em
    \item \nameref{wlr compositor}
    \item \nameref{wlr data device}
    \item \nameref{wlr keyboard}
    \item \nameref{wlr output}
    \item \nameref{wlr pointer}
    \item \nameref{wlr region}
    \item \nameref{wlr screenshooter}
    \item \nameref{wlr seat}
    \item \nameref{wlr server decoration}
    \item \nameref{wlr surface}
    \item \nameref{wlr tablet pad}
    \item \nameref{wlr tablet tool}
    \item \nameref{wlr touch}
    \item \nameref{wlr wl shell}
    \item \nameref{wlr xdg shell v6}
\end{itemize}

\subsection{Special Types}\label{special types}

Some types are spread throughout their respective subsystems and are not
included in \code{include/types/*.h}. These include:

\begin{itemize}
    \itemsep0em
    \item \nameref{wlr backend}
    \item \nameref{wlr renderer}
    \item \nameref{wlr texture}
    \item \nameref{wlr xcursor}
    \item \nameref{wlr xwayland}
\end{itemize}

\newpage
\section{Type Reference}\label{type reference}

\subsection{wlr_backend}\label{wlr backend}

\code{wlr/backend.h}\\

This type abstracts the functionality of hardware backends. For an overview of
this system and available backends see \nameref{high level backends}.

\subsection{wlr_box}\label{wlr box}

\code{wlr/types/wlr_box.h}\\

\textbf{wlr_box} is a simple data structure:

\begin{verbatim}
struct wlr_box {
    int x, y;
    int width, height;
};
\end{verbatim}

A number of utility functions are available in the header.

\subsection{wlr_compositor}\label{wlr compositor}

TODO

\subsection{wlr_cursor}\label{wlr cursor}

TODO

\subsection{wlr_data_device}\label{wlr data device}

TODO

\subsection{wlr_gamma_control}\label{wlr gamma control}

TODO

\subsection{wlr_input_device}\label{wlr input device}

TODO

\subsection{wlr_keyboard}\label{wlr keyboard}

TODO

\subsection{wlr_list}\label{wlr list}

TODO

\subsection{wlr_matrix}\label{wlr matrix}

TODO

\subsection{wlr_output}\label{wlr output}

\code{wlr/types/wlr_output.h}\\

\textbf{wlr_output} abstracts access to display hardware provided by backends.
The most important functionality offered by \textbf{wlr_outputs} is the frame
event. The output will raise this event when it is ready to accept a new frame.
You should make the EGL context current via \code{wlr_output_make_current},
render your frame, and use \code{wlr_output_swap_buffers} to present it.\\

Additionally, \textbf{wlr_outputs} offer hardware cursors. In the event that
hardware cursors are not supported on a particular backend, software cursors
are used automatically. TODO: the details of this functionality are going to
change.\\

\code{wlr/interfaces/wlr_output.h} contains an interface you may use to
provide your own wlr_output implementations.

\subsection{wlr_output_layout}\label{wlr output layout}

\code{wlr/types/wlr_output_layout.h}\\

\textbf{wlr_output_layout} provides a mechanism for arranging
\textbf{wlr_outputs} in physical space. It provides functionality for arranging
a virtual desktop, translating global coordinates to output space, and
intersecting boxes with outputs. It can also be used to mirror outputs.

\subsection{wlr_pointer}\label{wlr pointer}

TODO

\subsection{wlr_region}\label{wlr region}

TODO

\subsection{wlr_renderer}\label{wlr renderer}

TODO

\subsection{wlr_screenshooter}\label{wlr screenshooter}

TODO

\subsection{wlr_seat}\label{wlr seat}

TODO

\subsection{wlr_server_decoration}\label{wlr server decoration}

TODO

\subsection{wlr_surface}\label{wlr surface}

TODO

\subsection{wlr_tablet_pad}\label{wlr tablet pad}

TODO

\subsection{wlr_tablet_tool}\label{wlr tablet tool}

TODO

\subsection{wlr_texture}\label{wlr texture}

TODO

\subsection{wlr_touch}\label{wlr touch}

TODO

\subsection{wlr_wl_shell}\label{wlr wl shell}

TODO

\subsection{wlr_xcursor}\label{wlr xcursor}

TODO

\subsection{wlr_xdg_shell_v6}\label{wlr xdg shell v6}

TODO

\subsection{wlr_xwayland}\label{wlr xwayland}

TODO

\end{document}
